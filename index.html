
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Snake — Fullscreen + UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root {
      --bg: #1e1e1e;
      --hud-bg: rgba(0,0,0,0.35);
      --hud-border: #333;
      --text: #e6e6e6;
      --accent: #dc3c3c;            /* food color */
      --border-red: #e00000;        /* play-area border */
      --grid: #333;
      --btn: #505050;
      --btn-hover: #666;
      --btn-active: #808080;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    /* Top UI bar overlays the game */
    #topbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 56px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: var(--hud-bg);
      backdrop-filter: blur(4px);
      border-bottom: 1px solid var(--hud-border);
      z-index: 10;
    }

    .spacer { flex: 1; }

    button {
      background: var(--btn);
      color: var(--text);
      border: 1px solid #777;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: var(--btn-hover); }
    button.active { background: var(--btn-active); }

    #speed-buttons button { min-width: 90px; }

    /* Canvas is truly fullscreen; we size pixels via JS to fit a TILE grid */
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* Tiny status text */
    #hud {
      font-size: 14px;
      margin-left: 8px;
      opacity: 0.9;
    }

    /* Helper: prevent text selection during rapid clicks */
    * { user-select: none; }
  </style>
</head>
<body>
  <div id="topbar">
    <button id="pauseBtn" title="Space/P">⏸️ Pause</button>
    <div class="spacer"></div>

    <div id="speed-buttons" aria-label="Speed">
      <button data-speed="0">Slow</button>
      <button data-speed="1" class="active">Normal</button>
      <button data-speed="2">Fast</button>
      <button data-speed="3">Insane</button>
    </div>

    <div class="spacer"></div>

    <div id="hud">
      Score: <span id="score">0</span>
      &nbsp;•&nbsp; Controls: Arrow/WASD, Space/P to pause, 1–4 set speed
    </div>
  </div>

  <canvas id="game"></canvas>

  <script>
    // --- Polyfill for roundRect (for older browsers) ---
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        r = Math.max(0, Math.min(r, Math.min(w, h) / 2));
        this.beginPath();
        this.moveTo(x + r, y);
        this.lineTo(x + w - r, y);
        this.quadraticCurveTo(x + w, y, x + w, y + r);
        this.lineTo(x + w, y + h - r);
        this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        this.lineTo(x + r, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r);
        this.lineTo(x, y + r);
        this.quadraticCurveTo(x, y, x + r, y);
        this.closePath();
      };
    }

    // --- Config ---
    const TILE = 20;
    const GRID_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#333';
    const BG_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#1e1e1e';
    const BORDER_RED = getComputedStyle(document.documentElement).getPropertyValue('--border-red').trim() || '#e00000';
    const FOOD_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#dc3c3c';

    const PALETTE = [
      [0, 200, 80],
      [0, 180, 220],
      [255, 180, 0],
      [180, 80, 200],
      [200, 70, 70],
      [80, 200, 160],
    ];

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('pauseBtn');
    const speedButtons = Array.from(document.querySelectorAll('#speed-buttons button'));

    // Game state
    let WIDTH = 0, HEIGHT = 0;
    let snake = [];
    let dir = { x: TILE, y: 0 };
    let grow = 0;
    let score = 0;
    let paused = false;

    const speeds = [
      { label: 'Slow', fps: 8 },
      { label: 'Normal', fps: 12 },
      { label: 'Fast', fps: 16 },
      { label: 'Insane', fps: 20 },
    ];
    let currentSpeedIdx = 1; // Normal
    let stepMs = 1000 / speeds[currentSpeedIdx].fps;
    let accumulator = 0;
    let lastTs = 0;

    // Colors (head changes every 3 eats)
    let baseColor = PALETTE[0];
    let bodyColor = darker(baseColor, 0.8);

    // Food
    let food = { x: 0, y: 0 };

    // --- Helpers ---
    function rgb(c) { return `rgb(${c[0]}, ${c[1]}, ${c[2]})`; }
    function darker(c, factor = 0.8) {
      return [Math.round(c[0] * factor), Math.round(c[1] * factor), Math.round(c[2] * factor)];
    }

    function sizeCanvas(reset = true) {
      // Make canvas pixel size a multiple of TILE to keep grid aligned
      const w = Math.floor(window.innerWidth / TILE) * TILE;
      const h = Math.floor(window.innerHeight / TILE) * TILE;
      canvas.width = WIDTH = Math.max(TILE * 10, w);   // minimum area
      canvas.height = HEIGHT = Math.max(TILE * 8, h);

      if (reset) hardReset();
    }

    function randomCell() {
      const cols = WIDTH / TILE | 0;
      const rows = HEIGHT / TILE | 0;
      return {
        x: (Math.floor(Math.random() * cols)) * TILE,
        y: (Math.floor(Math.random() * rows)) * TILE
      };
    }

    function hardReset() {
      snake = [{ x: Math.floor(WIDTH / 2 / TILE) * TILE, y: Math.floor(HEIGHT / 2 / TILE) * TILE }];
      dir = { x: TILE, y: 0 };
      grow = 0;
      score = 0;
      scoreEl.textContent = score;
      food = spawnFood();
      setColorByScore(score);
    }

    function spawnFood() {
      let p;
      do { p = randomCell(); }
      while (snake.some(s => s.x === p.x && s.y === p.y));
      return p;
    }

    function setColorByScore(s) {
      const idx = Math.floor(s / 3) % PALETTE.length;
      baseColor = PALETTE[idx];
      bodyColor = darker(baseColor, 0.8);
    }

    function changeDir(nx, ny) {
      // Prevent reversing directly
      if (nx === -dir.x && ny === -dir.y) return;
      dir = { x: nx, y: ny };
    }

    function collideWall(h) {
      return h.x < 0 || h.x >= WIDTH || h.y < 0 || h.y >= HEIGHT;
    }
    function collideSelf(h) {
      return snake.slice(1).some(p => p.x === h.x && p.y === h.y);
    }

    // --- Drawing ---
    function drawGrid() {
      ctx.strokeStyle = GRID_COLOR;
      ctx.lineWidth = 1;
      for (let x = 0; x <= WIDTH; x += TILE) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, HEIGHT); ctx.stroke();
      }
      for (let y = 0; y <= HEIGHT; y += TILE) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WIDTH, y); ctx.stroke();
      }
    }

    function drawRect(x, y, color, radius = 4) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.roundRect(x, y, TILE, TILE, radius);
      ctx.fill();
    }

    function drawHead() {
      const h = snake[0];
      // Head block
      drawRect(h.x, h.y, rgb(baseColor), 6);

      // Eyes oriented to movement
      const dx = Math.sign(dir.x); // -1, 0, 1
      const dy = Math.sign(dir.y);

      const eyeR = Math.max(2, TILE / 6 | 0);
      const pupilR = Math.max(1, TILE / 10 | 0);

      let e1, e2, pupilOffset;
      if (dx === 1) {                 // right
        e1 = { x: h.x + TILE * 0.65, y: h.y + TILE * 0.35 };
        e2 = { x: h.x + TILE * 0.65, y: h.y + TILE * 0.65 };
        pupilOffset = { x: eyeR / 2, y: 0 };
      } else if (dx === -1) {         // left
        e1 = { x: h.x + TILE * 0.35, y: h.y + TILE * 0.35 };
        e2 = { x: h.x + TILE * 0.35, y: h.y + TILE * 0.65 };
        pupilOffset = { x: -eyeR / 2, y: 0 };
      } else if (dy === -1) {         // up
        e1 = { x: h.x + TILE * 0.35, y: h.y + TILE * 0.35 };
        e2 = { x: h.x + TILE * 0.65, y: h.y + TILE * 0.35 };
        pupilOffset = { x: 0, y: -eyeR / 2 };
      } else {                        // down
        e1 = { x: h.x + TILE * 0.35, y: h.y + TILE * 0.65 };
        e2 = { x: h.x + TILE * 0.65, y: h.y + TILE * 0.65 };
        pupilOffset = { x: 0, y: eyeR / 2 };
      }

      // Draw eyes + pupils
      ctx.fillStyle = 'white';
      for (const e of [e1, e2]) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, eyeR, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#141414';
        ctx.beginPath();
        ctx.arc(e.x + pupilOffset.x, e.y + pupilOffset.y, pupilR, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
      }
    }

    function drawBody() {
      ctx.fillStyle = rgb(bodyColor);
      for (let i = 1; i < snake.length; i++) {
        drawRect(snake[i].x, snake[i].y, rgb(bodyColor), 4);
      }
    }

    function drawFood() {
      drawRect(food.x, food.y, FOOD_COLOR, 4);
    }

    function drawBorder() {
      ctx.strokeStyle = BORDER_RED;
      ctx.lineWidth = 6;
      // Inset so the border is fully visible
      ctx.strokeRect(3, 3, WIDTH - 6, HEIGHT - 6);
    }

    function drawScene() {
      // Background
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // Grid + entities + border
      drawGrid();
      drawFood();
      drawBody();
      drawHead();
      drawBorder();
    }

    // --- Update & loop ---
    function update() {
      if (paused) return;

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      snake.unshift(head);

      if (grow > 0) { grow--; } else { snake.pop(); }

      if (collideWall(head) || collideSelf(head)) {
        hardReset();
        return;
      }

      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreEl.textContent = score;
        grow++;
        setColorByScore(score);     // change color every 3 eats
        food = spawnFood();
      }
    }

    function loop(ts) {
      if (!lastTs) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;

      accumulator += dt;
      while (accumulator >= stepMs) {
        update();
        accumulator -= stepMs;
      }

      drawScene();
      requestAnimationFrame(loop);
    }

    // --- UI wiring ---
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.classList.toggle('active', paused);
    });

    speedButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        speedButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSpeedIdx = Number(btn.dataset.speed);
        stepMs = 1000 / speeds[currentSpeedIdx].fps;
      });
    });

    document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === ' ' || k === 'p') {
        paused = !paused;
        pauseBtn.classList.toggle('active', paused);
      }
      if (paused) return;

      if (k === 'arrowup' || k === 'w') changeDir(0, -TILE);
      else if (k === 'arrowdown' || k === 's') changeDir(0, TILE);
      else if (k === 'arrowleft' || k === 'a') changeDir(-TILE, 0);
      else if (k === 'arrowright' || k === 'd') changeDir(TILE, 0);
      else if (k === '1' || k === '2' || k === '3' || k === '4') {
        currentSpeedIdx = Number(k) - 1;
        stepMs = 1000 / speeds[currentSpeedIdx].fps;
        speedButtons.forEach(b => b.classList.toggle('active', Number(b.dataset.speed) === currentSpeedIdx));
      }
    });

    // Optional: press "F" to request full browser fullscreen (not just fit-to-window)
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'f') {
        const el = document.documentElement;
        if (!document.fullscreenElement && el.requestFullscreen) el.requestFullscreen();
        else if (document.exitFullscreen) document.exitFullscreen();
      }
    });

    window.addEventListener('resize', () => sizeCanvas(true));

    // --- Boot ---
    sizeCanvas(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>

